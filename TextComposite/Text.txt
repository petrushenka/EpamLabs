 ласс Client может взаимодействовать только с экземпл€рами, реализующими 	
интерфейс Adapter. Ёкземпл€р класса Client, вызыва€ метод execute(),
не будет знать, метод какого класса он вызывает Ч основного или адаптируемого.
ѕредназначение шаблона Adapter Ч без серьезной переработки системы 
включить необходимый функционал в общем случае несовместимый
с существующим.

package by.bsu.adapter.base;
public interface Adapter {
void request();
}
package by.bsu.adapter.base;
public class ConcreteAdapter implements Adapter{
private Adaptee adaptee;
public ConcreteAdapter (Adaptee adaptee) {
this.adaptee = adaptee;
}
public void request() {
System.out.println("Return type - void.");
adaptee.specificRequest();
}
}.
–еализаци€, представленна€ выше, использует один класс типа Adaptee.
¬ общем случае эти классы могут быть организованы в иерархию и при инициализации
 объекта типа Adapter будет передаватьс€ объект из иерархии, и скрытое
 действие будет выполн€тьс€ в соответствии с конкретным типа объекта.
Ќо это уже будет не совсем шаблон Adapter.
	 ласс Adapter должен обладать механизмом согласовани€ параметров и способом
 трансл€ции вызова методов основного приложени€ и адаптируемого класса.
ѕусть в систему JSON-парсинга необходимо подключить разбор XML-документа. ƒл€
 этого выдел€етс€ интерфейс Parser с методом parse().
	—уществующий класс JsonParser теперь должен имплементировать новый интерфейс.
ƒл€ адаптации интерфейса класса XmlParser создаетс€ класс XmlParserAdapter, объ€вл€ющий 
адаптируемый класс в качестве пол€, а так-же 
в качестве полей объ€вл€ет необходимые дл€ согласовани€ интерфейса  
параметры. ћетод parse() адаптера теперь может корректно вызвать метод парсинга
 адаптируемого класса.
